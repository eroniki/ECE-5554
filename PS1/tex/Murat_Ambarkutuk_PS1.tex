\documentclass{article}

\usepackage{listings}
\usepackage{graphicx}
\usepackage{color} %red, green, blue, yellow, cyan, magenta, black, white
\usepackage{amsfonts}
\usepackage{mathtools}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{adjustbox}
\usepackage{hyperref}
\usepackage{float}

\newcommand{\listFigure}[3]{
	\begin{figure}[H]
		\includegraphics[width=\linewidth]{../matlab/#1}
		\caption{#2\label{fig:#3}}
	\end{figure}		
}


\definecolor{mygreen}{RGB}{28,172,0} % color values Red, Green, Blue
\definecolor{mylilas}{RGB}{170,55,241}
%% Preamble done!
%% Begin document
\begin{document}
\lstset{language=Matlab,%
    %basicstyle=\color{red},
    breaklines=true,%
    morekeywords={matlab2tikz},
    keywordstyle=\color{blue},%
    morekeywords=[2]{1}, keywordstyle=[2]{\color{black}},
    identifierstyle=\color{black},%
    stringstyle=\color{mylilas},
    commentstyle=\color{mygreen},%
    showstringspaces=false,%without this there will be a symbol in the places where there is a space
    numbers=left,%
    numberstyle={\tiny \color{black}},% size of the numbers
    numbersep=12pt, % this defines how far the numbers are from the text
    emph=[1]{for,end,break},emphstyle=[1]\color{red}, %some words to emphasise
    %emph=[2]{word1,word2}, emphstyle=[2]{style},    
}
\label{Cover}
	\begin{center}
	\large{ECE-5554 Computer Vision: Problem Set 1} 
	\vfill
	Murat Ambarkutuk \\ murata@vt.edu
	\vfill
	Mechanical Engineering Department,\\ Virginia Polytechnic Institute and State University
	\vfill
	\today
	\end{center}
\pagebreak 
\large{Answer Sheet}

\label{Short Answer Problems}
\section{Short Answer Problems}
\begin{enumerate}
	% 1- Give an example of how one can exploit the associative property of
	% convolution to more efficiently filter an image.
	\item The computational complexity of convolution for any arbitrary
	kernel ${F_0}_{[m\times n]}$ and image ${I_0}_{[M\times N]}$:
	$$\mathcal{O}(MNmn)$$
	Hence, applying various filters will drastically increase
	the computational cost of filtering process.\\
	For instance, ${F_0}_{[m\times n]} \ast ({F_1}_{[m\times n]} \ast
	{I_0}_{[M\times N]})$ will be computed with the complexity of $2 \times
	\mathcal{O}(MNmn)$. \\
	On the other hand, associative property of convolution can be
	utilizied by convolving the filters first, then applying the acquired filter to
	image:
	$({F_0}_{[m\times n]} \ast {F_1}_{[m\times n]}) \ast
	{I_0}_{[M\times N]}$ $$\mathcal{O}(m^2n^2) + \mathcal{O}(MNmn)$$
	Given that in any filtering process the size of filter
	kernel, by its nature, will be smaller than the image size, the computational
	complexity will be reduced thanks to the assosicative property of convolution.
	$$\mathcal{O}{(m^2n^2)} + \mathcal{O}(MNmn) \ll 2 \times \mathcal{O}(MNmn)$$
	% 2- This is the input image: [0 0 1 1 0 0 1 1]. What is the result of dilation
	% with a structuring element [1 1 1]?
	\item 
	$$\vec{I} = \begin{bmatrix} 0 & 0 & 1 & 1 & 0 & 0 & 1 & 1\end{bmatrix}
	, \vec{f}= \begin{bmatrix} 1 & 1 & 1\end{bmatrix}$$
	\begin{equation} 
	\begin{split}
	\vec{H} & = \vec{I} \bigoplus \vec{f} \\
	& = \begin{bmatrix} 0 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 \end{bmatrix}
	\end{split}
	\end{equation}
	% 3- The filter f’ = [0 -1/2 0 1/2 0] gives an estimate of the first derivative
	% of the image in the x direction.
	% What is the corresponding second derivative filter f". (Hint: Assymetric
	% filters must be flipped prior to convolution.)
	\item $ \vec{f''} = \begin{bmatrix}  0 & \frac{1}{2} & - \frac{1}{2} &
	-\frac{1}{2} & \frac{1}{2} & 0 \end{bmatrix}$
	% 4- Name two specific ways in which one could reduce the amount of fine, detailed edges that are detected
	% with the Canny edge detector.
	\item % TODO Read the Canny Edge Detection algorithm
	\begin{enumerate}
		\item Gaussian Kernel: Since Canny edge detection algorithm uses Gaussian
		filter to reduce noise. However, too big kernel will smooth out some of the
		detail in the input image. In that case, output image would have fewer fine
		edges.
		\item Wrong Thresholding: Setting too high numbers for high and low threshold
		would reduce the amount of fine and detailed edges. These values set the
		overall performance of the algorithm in the steps of double thresholding and
		hysteresis edge tracking. 
		% In the double thresholding step, any pixel whose
		% gradient magnitude is above than higher threshold is marked as 'strong
		% edges', while any pixel whose gradient value is within the high and low
		% threshold range, marked 'candidate edges'. On the other hand, all the pixels
		% whose gradient magnitude is below than low threshold are subject
		% elemination.
		In the double thresholding step, pixels are marked and categorized according
		to their gradient magnitude. Setting too high threshold values would miss some
		of the fine, detailed edges since they might have lower gradient magnitude
		values than high threshold value. Likewise, too high threshold
		values would have impact on performance of hysteresis edge tracking step.
	\end{enumerate}
	% 5- Describe a possible flaw in the use of additive Gaussian noise to
	% represent image noise.
	% TODO Additive Gaussian Noise, mean zero
	\item In real world applications noise occuring in the image may vary
	depending on many variables, namely, the lightning conditions of the
	environment in which the camera set up or the type of sensor that are being
	used. For that reason, modeling the noise with Gaussian noise may not describe
	the real world for each case of application. 
	% 6- Design a method that takes video data from a camera perched above a conveyor belt at an automotive
	% equipment manufacturer, and reports any flaws in the assembly of a part. Your
	% response should be a list of concise, specific steps, and should incorporate
	% several techniques covered in class thus far.
	% Specify any important assumptions your method makes. 
	% TODO Revise the solution flow
	\item A tentative flow of solution can be used for many generic vision
	problems:
	\begin{enumerate}
		\item Pre-processing (Preparation)
		\begin{enumerate}
			\item Data acquisition
			\item Data reduction (Downsampling, color space change \\
			(e.g. RGB, $\to$, Grayscale, defining region of interest\ldots) (if needed)
			\item Noise reduction (Morphological Operations)
		\end{enumerate}
		
		\item Processing (Analysis)
		\begin{enumerate}
	    	\item Detection
	    	\begin{enumerate}
	    		\item Object Detection (Either, or combinations of the steps given below)
	    			\begin{itemize}
	    				\item Background Substraction
	    				\item Feature (Color, geometry, edge, depth \ldots) based (Connected
	    				Components may be utilized with the combination of thresholding)
	    				\item Texture based  				
	    			\end{itemize}
	    		\item Defect detection on the detected object
	    			\begin{itemize}
	    				\item Feature based
	    					\begin{itemize}
	    						\item Color consistency 
	    						\item Geometrical Properties (Hough circles and/or lines can be fitted to check shape defects)
	    						\item Depth data also may give hint on the surface imperfections
	    					\end{itemize}
	    				\item Texture based (Imperfections would change the texture	statistics)		
	    			\end{itemize}
	    	\end{enumerate}
		\end{enumerate}
	\end{enumerate}
\end{enumerate}
\pagebreak

\label{Programming Problem (Seam Carving)}
\section{Programming Problem (Seam Carving)}
\begin{enumerate}
	\label{Answer 1}
	\item Width Reducing
	% Write a script called SeamCarvingReduceWidth.m(py) which does the following by using
	% the functions defined above:
	% (a) Loads a color input image called inputSeamCarvingPrague.jpg. Download the
	% image from here (http://filebox.ece.vt.edu/~F15ECE5554ECE4984/resources/images/inputSeamCarvingPrague.
	% jpg)
	% 2(b) Reduces the width of the image by 100 pixels using the above functions.
	% (c) Saves the resulting image as outputReduceWidthPrague.png. Submit it.
	% Display this output in your answer sheet. Submit the script.
	% (d) Repeat the steps for an input image called inputSeamCarvingMall.jpg.
	% Download the image from here
	
	% (http://filebox.ece.vt.edu/~F15ECE5554ECE4984/resources/images/inputSeamCarvingMall.
	% jpg). Save the output as outputReduceWidthMall.png. Display the output in
	% your answer sheet.
	\begin{enumerate} 
		\item Prague (Width Resizing) \\
		\begin{enumerate}
			\item Originial Image: \\
			\listFigure{inputSeamCarvingPrague.jpg}{Input Image (Prague, 640 $\times$
			480)}{inputSeamCarvingPrague}
			\pagebreak
			\item Resized Image: \\
			\listFigure{outputReduceWidthPrague.png}{Resized Image (Prague, Width, 540 $\times$ 480)}{outputReduceWidthPrague}
			\pagebreak
			\item Comparison: \\
			\listFigure{outputReduceWidthInputvsDynamicPrague.png}{Comparison
			Image}{outputReduceWidthInputvsDynamicPrague}
			Legend for comparison image.
			\begin{itemize}
				\item Gray pixels: Common (shared) pixels on both images.
				\item Green pixels: The pixels that output image introduces.
				\item Magenta pixels: The pixels that output image lacks.
			\end{itemize}
		\end{enumerate}
		
		\pagebreak
		\item Mall (Width Resizing)\\
		\begin{enumerate}
			\item Originial Image: \\
			\listFigure{inputSeamCarvingMall.jpg}{Input Image (Mall, 775 $\times$
			769)}{inputSeamCarvingMall}
			\pagebreak
			\item Resized Image: \\
			\listFigure{outputReduceWidthMall.png}{Resized Image (Mall, Width, 675
			$\times$ 769)}{outputReduceWidthMall}
			\pagebreak
			\item Comparison: \\
			\listFigure{outputReduceWidthInputvsDynamicMall.png}{Comparison
			Image}{outputReduceWidthInputvsDynamicMall}
			Legend for comparison image.
			\begin{itemize}
				\item Gray pixels: Common (shared) pixels on both images.
				\item Green pixels: The pixels that output image introduces.
				\item Magenta pixels: The pixels that output image lacks.
			\end{itemize}
		\end{enumerate}
		\pagebreak
		\item Script: SeamCarvingReduceWidth.m
		\lstinputlisting{../matlab/SeamCarvingReduceWidth.m}
	\end{enumerate}
	\pagebreak
	
	\item Height Resizing \\
		\begin{enumerate} 
		\item Prague (Height Resizing) \\
		\begin{enumerate}
			\item Originial Image: Please see Figure-\ref{fig:inputSeamCarvingPrague} \\
			\item Resized Image: \\
			\listFigure{outputReduceWidthPrague}{Resized Image (Prague, Height, 640
			$\times$ 380)}{outputReduceHeightPrague}
			\pagebreak
			\item Comparison: \\
			\listFigure{outputReduceHeightInputvsDynamicPrague.png}{Comparison of Input Image and Output of Dynamic Programming
				Implementation}{outputReduceHeightInputvsDynamicPrague}
			Legend for comparison image.
			\begin{itemize}
				\item Gray pixels: Common (shared) pixels on both images.
				\item Green pixels: The pixels that output image introduces.
				\item Magenta pixels: The pixels that output image lacks.
			\end{itemize}
		\end{enumerate}
		\pagebreak
		
		\item Mall (Height Resizing) \\
		\begin{enumerate}
			\item Originial Image: Please see Figure-\ref{fig:inputSeamCarvingMall} \\
			\item Resized Image: \\
			\listFigure{outputReduceHeightMall.png}{Resized Image (Mall, Height, 775
			$\times$ 669)}{outputReduceHeightMall}
			\pagebreak
			\item Comparison: \\
			\listFigure{outputReduceHeightComparisonOutputsMall.png}{Comparison of Input Image and Output of Dynamic Programming
				Implementation}{outputReduceHeightComparisonOutputsMall}
			Legend for comparison image.
			\begin{itemize}
				\item Gray pixels: Common (shared) pixels on both images.
				\item Green pixels: The pixels that output image introduces.
				\item Magenta pixels: The pixels that output image lacks.
			\end{itemize}
		\end{enumerate}
		\pagebreak 
		\item Script: SeamCarvingReduceHeight.m
		\lstinputlisting{../matlab/SeamCarvingReduceHeight.m}
	\end{enumerate}

	\item 
	% 3- Display in your answer sheet: (a) the energy function output for the
	% provided image inputSeamCarvingPrague.jpg, and (b) the two corresponding cumulative minimum
	% energy maps for the seams in each direction (use the Matlab’s imagesc or
	% Python’s matplotlib.pyplot.imshow).
	% Explain why these outputs look the way they do given the original image’s
	% content.
	\listFigure{cumulatives.png}{Input Image, Energy Map and
	Cumulative Energy Functions}{cumulatives}	
	As seen on Figure-\ref{fig:cumulatives}, the elements of horizontal cumulative
	energy map is increasing through west to east direction since it is the same
	direction which the algorithm adds up minimum 8-connected element computed in the previous step. \\
	Likewise, the elements in vertical cumulative energy map is increasing in
	north to south direction. \\
	Due to the fact that energy level of each pixel is not still, the final
	distribution of accummulated energy levels vary. The horizontal cumulative
	energy map adds up the bottom region since the ripples of the water surface
	and the reflection caused by these ripples creates high differences among
	neighboring pixels. Along with that, the lowest region of the same map is
	where all the pixels related to sky were add up.
	\pagebreak

	\item
	% 4- For the same image inputSeamCarvingPrague.jpg, display the original image
	% together with (a) the first selected horizontal seam and (b) the first selected
	% vertical seam in your answer sheet. Explain why these are the optimal seams for this image.
	\listFigure{seams.png}{Red Pixels: Optimal Vertical Seam, Blue
	Pixels: Optimal Horizontal Seam}{seams}
	As the cumulative energy maps show in Figure-\ref{fig:cumulatives}, eastern
	part of the horizontal cumulative energy map and southern part of the vertical
	cumulative energy map display the highest energy accumulation, where dynamic
	programming algorithm accumulates the energy differences of neighboring pixels.
	Starting from minima of those regions, the algorithm finds the lowest energy
	accumulation of 8-connected neighbors. This way, the algorithm tries to find
	the seam which connects the lowest energy pixels without leaving the
	8-connected region. \\
	In other words, the algorithm chooses the lowest energy
	elements by finding from most bottom row or from most right column, for
	vertical or horizontal resizing, respectively. The algorithm then starts proceeding
	choosing one row above or one column left with the same procedure. \\
	Hence, the algorithm finally results finding the seam which connecting lowest
	energy elements without choosing too far away elements.
	(Please see: Figure-\ref{fig:seams})
	\item
	% 5- Make some change to the way the energy function is computed (i.e., filter
	% used, its parameters, or incorporating some other prior knowledge). Display the result and
	% explain the impact on the results for some example in your answer sheet. You need not submit this code.
	New energy function used is Laplacian of Gaussian;
	\begin{lstlisting}
	function energyMap = energy_image(im)
	%%% New Energy Function Laplacian of Gaussian (LoG)
	frameGray = rgb2gray(im);  
	LoG = conv2(fspecial('laplacian'),fspecial('gaussian'));
	energyMap = imfilter(frameGray, LoG); 
	end		
	\end{lstlisting}	
	\listFigure{cumulatives-2.png}{New Cumulative Energy Map with
	LoG}{cumulatives2}
	As Figure-\ref{fig:cumulatives2} illustrates; applying LoG filter rather than
	Prewitt makes algorithm less aware of the changes since, Gaussian has smoothing
	effect. Thus, the position of first seams drastically changed. To see the
	change please compare \ref{fig:seams} and \ref{fig:seams2}.
    \listFigure{seams-2.png}{The first seams with LoG, Red and Blue Pixels
    depict Optimal and Horizontal Vertical Seams, respectively.}{seams2}
	\item Qualitative Results
	% 6- Now, for the real results! Use your system with different kinds of images
	% and seam combinations, and see what kind of interesting results it can produce. The goal is
	% to form some perceptually pleasing outputs where the resizing better preserves content than a blind resizing would, as well as
	% some examples where the output looks unrealistic or has artifacts.
	% Include results for at least three images of your own choosing. Include an
	% example or two of a "bad" outcome. Be creative in the images you choose, and in the amount of combined vertical and horizontal
	% carvings you apply. Try to predict types of images where you might see
	% something interesting happen.
	% It’s ok to fiddle with the parameters (seam sequence, number of seams, etc) to
	% look for interesting and explainable outcomes.
	% For each result, include the following things, clearly labeled:
	% (a) the original input image.
	% (b) your system’s resized image,
	% (c) the result one would get if instead a simple resampling were used (via
	% Matlab’s imresize or Python’s scipy.misc.imresize)
	% (d) the input and output image dimensions,
	% (e) the sequence of removals that were used
	% (f) a qualitative explanation of what we’re seeing in the output.
	
\end{enumerate}
\pagebreak

\label{Extra Credit}
\section{Extra Credit}
\begin{enumerate}
	\item
	% \setcounter{enumi}{4}
	\item 
\end{enumerate}
\end{document}
